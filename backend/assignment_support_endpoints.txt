# Assignment Endpoints
@app.post("/assignments", response_model=AssignmentRead)
def create_assignment(assignment: AssignmentCreate, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    db_assignment = Assignment(**assignment.dict())
    session.add(db_assignment)
    session.commit()
    session.refresh(db_assignment)
    return db_assignment

@app.get("/assignments", response_model=List[AssignmentRead])
def read_assignments(batch_id: Optional[int] = None, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    if batch_id:
        return session.exec(select(Assignment).where(Assignment.batch_id == batch_id)).all()
    return session.exec(select(Assignment)).all()

# Submission Endpoints
@app.post("/submissions", response_model=SubmissionRead)
def create_submission(submission: SubmissionCreate, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    db_submission = Submission(
        assignment_id=submission.assignment_id,
        student_id=current_user.id,
        content=submission.content,
        file_url=submission.file_url
    )
    session.add(db_submission)
    session.commit()
    session.refresh(db_submission)
    return db_submission

@app.get("/submissions", response_model=List[SubmissionRead])
def read_submissions(assignment_id: Optional[int] = None, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    if assignment_id:
        return session.exec(select(Submission).where(Submission.assignment_id == assignment_id)).all()
    if current_user.role == "student":
        return session.exec(select(Submission).where(Submission.student_id == current_user.id)).all()
    return session.exec(select(Submission)).all()

@app.put("/submissions/{submission_id}/grade")
def grade_submission(submission_id: int, feedback: str, grade: str, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    submission = session.get(Submission, submission_id)
    if not submission:
        raise HTTPException(status_code=404, detail="Submission not found")
    
    submission.feedback = feedback
    submission.grade = grade
    submission.status = "graded"
    session.add(submission)
    session.commit()
    return {"message": "Submission graded successfully"}

# Certificate Endpoint
@app.get("/certificates/{student_id}")
def generate_certificate(student_id: int, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    student = session.get(User, student_id)
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")
    
    # Get student's enrollment
    enrollment = session.exec(select(Enrollment).where(Enrollment.student_id == student_id, Enrollment.status == "completed")).first()
    if not enrollment:
        raise HTTPException(status_code=404, detail="No completed enrollment found")
    
    batch = session.get(Batch, enrollment.batch_id)
    course = session.get(Course, batch.course_id)
    
    # Generate certificate
    from datetime import datetime
    cert_path = certificate_service.generate_certificate(
        student_name=student.name,
        course_name=course.title,
        completion_date=datetime.now().strftime("%B %d, %Y")
    )
    
    return {"message": "Certificate generated", "path": cert_path}

# Support Ticket Endpoints
@app.post("/support", response_model=SupportTicketRead)
def create_support_ticket(ticket: SupportTicketCreate, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    db_ticket = SupportTicket(
        user_id=current_user.id,
        subject=ticket.subject,
        message=ticket.message
    )
    session.add(db_ticket)
    session.commit()
    session.refresh(db_ticket)
    return db_ticket

@app.get("/support", response_model=List[SupportTicketRead])
def read_support_tickets(session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    if current_user.role == "admin":
        return session.exec(select(SupportTicket)).all()
    return session.exec(select(SupportTicket).where(SupportTicket.user_id == current_user.id)).all()

@app.put("/support/{ticket_id}/respond")
def respond_to_ticket(ticket_id: int, response: str, session: Session = Depends(get_session), current_user: User = Depends(auth.get_current_user)):
    ticket = session.get(SupportTicket, ticket_id)
    if not ticket:
        raise HTTPException(status_code=404, detail="Ticket not found")
    
    ticket.response = response
    ticket.status = "closed"
    from datetime import datetime
    ticket.updated_at = datetime.utcnow()
    session.add(ticket)
    session.commit()
    return {"message": "Response added successfully"}
